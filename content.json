{"meta":{"title":"TJ's blog","subtitle":"","description":"","author":"T","url":"http://example.com","root":"/"},"pages":[{"title":"bangumi","date":"2020-10-25T04:03:52.000Z","updated":"2020-10-26T01:43:00.075Z","comments":false,"path":"bangumi/index.html","permalink":"http://example.com/bangumi/index.html","excerpt":"","text":""},{"title":"comment","date":"2020-10-25T08:42:31.000Z","updated":"2020-10-27T09:06:29.689Z","comments":true,"path":"comment/index.html","permalink":"http://example.com/comment/index.html","excerpt":"","text":""},{"title":"donate","date":"2020-10-25T08:44:53.000Z","updated":"2020-10-26T14:38:03.224Z","comments":false,"path":"donate/index.html","permalink":"http://example.com/donate/index.html","excerpt":"","text":""},{"title":"links","date":"2020-10-28T08:44:14.000Z","updated":"2020-10-27T02:57:48.487Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Moments","date":"2020-10-27T16:05:57.979Z","updated":"2020-10-27T16:05:57.979Z","comments":false,"path":"shuoshuo/index.html","permalink":"http://example.com/shuoshuo/index.html","excerpt":"","text":"说说正在测试中，只有我本人可以在这里发说说，如果需要，可以来找我获取密码哦 new Artitalk({ appId: 'JCfKh8McwlVEmiw1DiQgwvAn-MdYXbMMI', appKey: 'hLX33F9ecRRXK0F6Uyy1RcDG' , })"},{"title":"music","date":"2020-10-26T08:38:02.000Z","updated":"2020-10-27T15:20:15.663Z","comments":true,"path":"music/index.html","permalink":"http://example.com/music/index.html","excerpt":"","text":"正在努力建设中！！！！！！！！！！！！！！！！最近很忙，没时间填补这边的内容！！见谅讲个冷笑话一块玻璃从高楼掉到地上，它说了什么？？？答案：晚安！！早点睡吧，孩子。"},{"title":"tags","date":"2020-10-25T09:55:08.000Z","updated":"2020-10-26T01:42:56.498Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"http和https的区别","date":"2020-10-26T15:43:48.001Z","updated":"2020-10-26T15:43:48.002Z","comments":true,"path":"2020/10/26/http和https的区别/","link":"","permalink":"http://example.com/2020/10/26/http%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"http和https的区别今天访问自己的网站时，发现网站名称前面，有不安全的红字，很纳闷，后来发现，我的网站时http访问的，非HTTPS，那么，这两者的区别是什么呢？ 首先httpHTTP是明文传输协议，传输内容容易被嗅探和篡改。 HTTPS即HTTP over SSL/TLS,是添加了一层SSL(Secure Sockets Layer，安全套接层)**，或者是TLS(Transport Layer Security,传输层安全协议)，所以HTTPS就可以视为HTTP和SSL/TLS协议的组合。**HTTPS能做到良好的保密性(防嗅探)，真实性(防篡改)，完整性(防域名劫持和域名欺骗)。 什么是SSL证书？SSL是TLS的前身，但TLS通常也被标志为SSL。SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息(会话秘钥)，服务器收到密文后，用自己的私钥解密。这个公钥就放在数字证书中。只要证书是可信的，公钥就是可信的。这个就设计公钥私钥了。","categories":[],"tags":[]},{"title":"LIFE","slug":"life","date":"2020-10-24T13:22:18.000Z","updated":"2020-10-26T14:08:17.069Z","comments":true,"path":"2020/10/24/life/","link":"","permalink":"http://example.com/2020/10/24/life/","excerpt":"","text":"时间：半个月 折腾：为更好的美化和给博客添加新功能，每天都在查资料，加班。 域名：域名的申请备案也花了很多时间。 结局: 看到自己完成了博客网站的搭建，满满的成就感。 终于搭好了自己的博客，yeah！！！！！！！！！ 以后更有动力写博客了！！","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://example.com/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"Spring Boot","slug":"spring boot","date":"2020-10-24T09:30:14.000Z","updated":"2020-10-25T09:21:18.324Z","comments":true,"path":"2020/10/24/spring boot/","link":"","permalink":"http://example.com/2020/10/24/spring%20boot/","excerpt":"","text":"spring boot的基本配置介绍 pom.xml spring-boot-dependencies:核心依赖在父工程中！ 引入spring-boot，不需要指定版本，存在版本仓库 spring-boot的启动器 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> 主程序@SpringBootApplication public class SpringbootApplication extends WebMvcConfigurerAdapter &amp;#123; public static void main(String[] args) &amp;#123; SpringApplication.run(SpringbootApplication.class, args); &amp;#125; &amp;#125; @SpringBootApplication:标注这个类是一个springboot应用，启动类下所有资源被导入 我们点开@SpringBootApplication @Sp@Target(&amp;#123;ElementType.TYPE&amp;#125;) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = &amp;#123;@Filter( type = FilterType.CUSTOM, classes = &amp;#123;TypeExcludeFilter.class&amp;#125; ), @Filter( type = FilterType.CUSTOM, classes = &amp;#123;AutoConfigurationExcludeFilter.class&amp;#125; )&amp;#125; ) public @interface SpringBootApplication &amp;#123; @SpringBootConfiguration：spring-boot的配置 //点开SpringBootConfiguration @Target(&amp;#123;ElementType.TYPE&amp;#125;) @Retention(RetentionPolicy.RUNTIME) @Documented @Configuration public @interface SpringBootConfiguration &amp;#123; @AliasFor( annotation = Configuration.class ) boolean proxyBeanMethods() default true; &amp;#125; @Configuration：pring配置类 @Compnent：也是spring boot 的一个组件 @EnableAutoConfiguration：自动配置 @Target(&#123;ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(&#123;AutoConfigurationImportSelector.class&#125;) public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;; &#125; @AutoConfigurationPackage：自动配置包 @Import({AutoConfigurationImportSelector.class})：自动配置导入选择器 超多的自动配置为什么没有生效，需要导入对应的start才能生效，因为注解@ConditionalOnXXX（核心注解）：如果这里面的条件满足，配置才会生效。不导入@ConditionalOnXXX（核心注解）下回报红。 结论：所有的springboot配置都是在启动的时候扫描并加载：spring.factory ，所有的自动配置类都在spring.factory都在里面， 但是不一定生效，因为注解@ConditionalOnXXX，要判断它的条件是否成立，只需要导入对应的start，就有对应的启动器，我们自动装配生效，配置成功！！！！ springboot启动时，从类路径/MATA-INF/spring.factory获取指定值 然后将这些自动配置类导入容器，自动配置就会生效，进行自定配置 之前自配的东西，springboot帮我们做了 整合java ee，解决方案和自动配合的东西都在spring-boot-autoconfigure-2.2.0 Relesaes .jar包 需要的组件，以类名的方式返回，这些组件就会添加到容器中 容器存在许多xxxautoConfiguraion（@Bean）就是这些给容器导入了场景所需要的组件，并进行自动配置@Configguration ，javaConfig","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}],"author":"TianJin"},{"title":"JSR303校验","slug":"JSR303校验","date":"2020-10-24T09:30:14.000Z","updated":"2020-10-26T08:00:14.156Z","comments":true,"path":"2020/10/24/JSR303校验/","link":"","permalink":"http://example.com/2020/10/24/JSR303%E6%A0%A1%E9%AA%8C/","excerpt":"","text":"JSR303校验 使用前导入依赖————&gt;(保证数据的安全和正确) &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-validation&lt;/artifactId> &lt;/dependency> @Component @ConfigurationProperties(prefix = \"person\") @Validated//数据校验（开启） public class Person &amp;#123; @Email(message = \"邮箱不合法\")//里面带有默认值，可修改 private String email; @NotNull private Integer id; private String name; private List&lt;String> hobby; 注解参数 @Null 限制只能为null @NotNull 限制必须不为null @AssertFalse 限制必须为false @AssertTrue 限制必须为true @DecimalMax(value) 限制必须为一个不大于指定值的数字 @DecimalMin(value) 限制必须为一个不小于指定值的数字 @Digits(integer,fraction) 限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction @Future 限制必须是一个将来的日期 @Max(value) 限制必须为一个不大于指定值的数字 @Min(value) 限制必须为一个不小于指定值的数字 @Past 限制必须是一个过去的日期 @Pattern(value) 限制必须符合指定的正则表达式 @Size(max,min) 限制字符长度必须在min到max之间 @Past 验证注解的元素值（日期类型）比当前时间早 @NotEmpty 验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0） @NotBlank 验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的空格 @Email 验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}],"author":"TianJin"},{"title":"spring boot多环境配置及文件位置","slug":"spring boot多环境配置及文件位置","date":"2020-10-24T09:30:14.000Z","updated":"2020-10-26T08:01:23.050Z","comments":true,"path":"2020/10/24/spring boot多环境配置及文件位置/","link":"","permalink":"http://example.com/2020/10/24/spring%20boot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"spring boot多环境配置及文件位置 spring boot 配置文件（application.yaml / xml）优先级：官方文档 file:./config/ - 优先级最高（项目根路径下的config） file:./ - 优先级第二 -（项目根路径下） classpath:/config/ - 优先级第三（项目resources/config下） classpath:/ - 优先级第四（项目resources根目录） spring boot切换环境配置 使用spring.profiles.active = ??? 切换配置环境,如下 | spring profiles: active: 配置文件名 spring.profiles.active=配置文件名 但是配置文件太多文件目录可能有点乱，那么yaml的优势就来了，如果你有多个配置，可以放在一个yaml中 server: #默认 port: 8080 server: port: 8089 spring: #one配置 profiles: one server: port:9090 spring: #two配置 profiles: two spring profiles: active: 配置文件名 如果我们要选择要用的配置，可以使用spring.profiles.active=配置名在一个yaml文件中切换（没有profiles属性的是默认选择）。 spring boot自动配置spring boot的@SpringBootApplication下的源码如下 @Target(&amp;#123;ElementType.TYPE&amp;#125;) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = &amp;#123;@Filter( type = FilterType.CUSTOM, classes = &amp;#123;TypeExcludeFilter.class&amp;#125; ), @Filter( type = FilterType.CUSTOM, classes = &amp;#123;AutoConfigurationExcludeFilter.class&amp;#125; )&amp;#125; ) ​````````````````````````````````下面还有很多 @EnableAutoConfiguration 和自动配置相关，打开源码 @Target(&amp;#123;ElementType.TYPE&amp;#125;) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(&amp;#123;AutoConfigurationImportSelector.class&amp;#125;) public @interface EnableAutoConfiguration &amp;#123; String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?>[] exclude() default &amp;#123;&amp;#125;; String[] excludeName() default &amp;#123;&amp;#125;; &amp;#125; 在@EnableAutoConfiguration下存在@Import({AutoConfigurationImportSelector.class}) ，这个就是选择导入，从这里进入找到 getAutoConfigurationEntry(省略了很多)，这个实体从 List configurations = this.getCandidateConfigurations(annotationMetadata, attributes);这个里面获得实体，然后或偶去配置，获取配置从 protected List&lt;String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &amp;#123; List&lt;String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\"); return configurations; &amp;#125; 这里获取配置this.getBeanClassLoader() 标注了注解类，所以能够找到，在上面的private ClassLoader beanClassLoader;这里， 然后从这里在这里返回已经标志了的类,如下 protected List&lt;String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &amp;#123; List&lt;String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\"); return configurations; &amp;#125; 从this.getSpringFactoriesLoaderFactoryClass(), 这里返回 protected ClassLoader getBeanClassLoader() &amp;#123; return this.beanClassLoader; &amp;#125; spring boot读取的资源自动装配，最终指向配置文件FACTORIES_RESOURCE_LOCATION = “META-INF/spring.factories”，源码如下 public final class SpringFactoriesLoader &amp;#123; public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\"; private static final Log logger = LogFactory.getLog(SpringFactoriesLoader.class); private static final Map&lt;ClassLoader, MultiValueMap&lt;String, String>> cache = new ConcurrentReferenceHashMap(); private SpringFactoriesLoader() &amp;#123; &amp;#125; 这个文件特别牛批！！！！！！我们的配置和它密切相关，无论哪一个，都带有注释@Configration 被配置！！！！！spring帮我们配置了很多东西，我们只需要直接用，spring boot牛皮！！！！！！！！！！！！！！！！ spring的底层注解@CondionalOnXXXX，根据不同的条件，判断当前配置或者类是否生效！！！！！！！！！ ​ xxxAutoConfiguration 《—- xxxProperties 《—– 配置文件","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}],"author":"TianJin"},{"title":"yaml文件实体类赋值","slug":"sprint boot主启动类","date":"2020-10-24T09:30:14.000Z","updated":"2020-10-26T14:08:15.854Z","comments":true,"path":"2020/10/24/sprint boot主启动类/","link":"","permalink":"http://example.com/2020/10/24/sprint%20boot%E4%B8%BB%E5%90%AF%E5%8A%A8%E7%B1%BB/","excerpt":"","text":"sprint boot主启动类 SpringApplication 推断应用的类型是普通的项目还是web项目 @SpringBootApplication，启动入口，可以自建一个类标注注解作为spring boot主启动 关于spring boot：自动装配，run（） run（） SpringApplication实例初始化：a)、根据classpath里面是否存在特征类（org.springframework.web.context.ConfigurableWebApplicationCobtext）来决定创建为web应用使用ApplicationContext类型，还是标准Standalone应用使用的ApplicationContext类型。b)、使用SpringFactoriesLoader在classpath中查找并加载所有可用的ApplicationContextInitiazierc)、使用SpringFactoriesLoader在classpath中查找并加载所有可用的ApplicationListenerd)、推断并main方法的定义类 SpringApplication实例初始化完成，遍历SpringFactoriesLoader可以找到并加载的SpringApplicationRunListnner，调用他们的start()方法。 创建并配置当前SpringBoot应用将要使用的Envrioment（包括配置要使用的PropertySource以及Profile） 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法——即通知【run监听器SpringBoot应用的使用环境已经搭建完成】 创建对应类型的ApplicationContext，根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator、ResourceLoader。将之前准备好的Enviroment设置给创建好的ApplicationContext使用 完成创建ApplicationContext，通过SpringFactoriesLoader查找并加载classpath中所有可用的ApplicationContextInitializer的Initialize（）方法来对ApplicationContext进行进一步的处理 遍历所有的SpringApplicationRunListenner的contextPrepared（）方法，通知【run监听器】ApplicationContext已经准备好了。 将之前通过**@EnableAutoConfiguration**获取的所有配置以及其他形式的IOC容器配置加载到已经准备完毕的ApplicationContext 遍历所有的SpringApplicationRunListener的contextLoaded（）方法，通知【run监听器和ApplicationContext装填完毕】 调用ApplicationContext的refresh（）——完成填充IOC容器 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。 遍历执行SpringApplicationRunListener的finished（）。——启动完毕","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"悦读","slug":"悦读","permalink":"http://example.com/tags/%E6%82%A6%E8%AF%BB/"}],"author":"tianjin"},{"title":"解决访问代理商问题","slug":"本地代理商的解决办法","date":"2020-10-24T09:30:14.000Z","updated":"2020-10-26T01:50:14.240Z","comments":true,"path":"2020/10/24/本地代理商的解决办法/","link":"","permalink":"http://example.com/2020/10/24/%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%90%86%E5%95%86%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"本地代理商的解决办法##网站移动可以访问，其他不行解决方法 ​ 今天进入github的git page时发现，自己网络能够访问，其他的不行，自己的是移动，别人都是电信等等其他的网络，这让我觉得，就是代理商的问题了。解决方法：挂代理 首先可以去这里（http://ping.chinaz.com/）查看自己网站的各代理的延迟情况，如下是我自己的 在 C:\\Windows\\System32\\drivers\\etc 下添加代理！！选择延迟最少的加上！这个文档是没有后缀名的，不要怀疑！！ ​ ##注意点：你在一些服务器软件上可能设置过域名，就是有时你突然设置一百度www.baidu.com的域名在上面，系统会给你记录在这里，我之前用phpstudy就这样，那时老怀疑为啥一直访问不上百度的首页，系统默认访问你本地域名了，没绑定啥，当然访问不到，所以，在这里删除之后就能够访问了！！！！ 我们就选一个延迟低的加入吧^_^,就下面这个吧，哈哈 江西九江[电信] 185.199.111.153 美国 GitHub+Fastly节点 91ms 52 如下 ##重启电脑，搞定！！！！就能够访问了。。。。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}],"author":"TianJin"},{"title":"什么是前后端分离","slug":"web","date":"2020-10-24T09:30:14.000Z","updated":"2020-10-25T09:02:33.150Z","comments":true,"path":"2020/10/24/web/","link":"","permalink":"http://example.com/2020/10/24/web/","excerpt":"","text":"概念:前端代码后端代码分开写 非前后端分离会发生的问题 传统web，前端由jsp开发，jsp非后端开发独立完成 前端–&gt;html静态页面–&gt;后端–&gt;jsp（后端可能看不懂前端） 前端只需要独立编写客户端代码，后端只需要独立编写服务器代码提供数据接口即可。 前端通过Ajax请求来访问后端的数据接口，将Model展现到View中即可 前端开发者只需要提前约定好接口文档（url，参数，数据类型）分别独立开发，前端可以用假的数据进行测试，不依赖于后端，解耦，极大提高开发效率。 前后端分离解决了一个问题 那就是静态资源(页面)和动态资源(数据接口)的分离，以前的jsp因为是直接把数据嵌入页面的导致页面资源也是动态的，接下来需要引入cdn缓存的概念，涉及的是运维方面的知识，静态资源一旦进入缓存，是可以有效降低服务器的负载的，这才是重点，也就是性能的提升。 所以前后端分离将一个单体应用拆分为两个独立的应用，前后端以json格式进行数据交互！！！！","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"悦读","slug":"悦读","permalink":"http://example.com/tags/%E6%82%A6%E8%AF%BB/"}],"author":"tianjin"},{"title":"yaml文件实体类赋值","slug":"yaml文件实体类赋值","date":"2020-10-24T09:30:14.000Z","updated":"2020-10-26T08:02:40.340Z","comments":true,"path":"2020/10/24/yaml文件实体类赋值/","link":"","permalink":"http://example.com/2020/10/24/yaml%E6%96%87%E4%BB%B6%E5%AE%9E%E4%BD%93%E7%B1%BB%E8%B5%8B%E5%80%BC/","excerpt":"","text":"yaml文件实体类赋值 实体类Person package cn.tj.springboot.entity; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; import java.util.List; @Component @ConfigurationProperties(prefix = \"person\") public class Person &amp;#123; private Integer id; private String name; private List&lt;String> hobby; public Integer getId() &amp;#123; return id; &amp;#125; public void setId(Integer id) &amp;#123; this.id = id; &amp;#125; public String getName() &amp;#123; return name; &amp;#125; public void setName(String name) &amp;#123; this.name = name; &amp;#125; public List&lt;String> getHobby() &amp;#123; return hobby; &amp;#125; public void setHobby(List&lt;String> hobby) &amp;#123; this.hobby = hobby; &amp;#125; &amp;#125; yaml文件 person: id: 1 name: tianjin$&amp;#123;random.uuid&amp;#125; #yaml文件可以加占位符$&amp;#123;random.uuid&amp;#125; hobby: - sleep - food - paly 通过@ConfigurationProperties(prefix = “person”)获取实体类属性的值 ，只有组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能 默认根据application.yaml配置文件，如果要加载指定的yaml文件，通过@PropertySource(value = “class:path:(yaml文件)”)，取值@Value（“${name}”","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"悦读","slug":"悦读","permalink":"http://example.com/tags/%E6%82%A6%E8%AF%BB/"}],"author":"tianjin"}],"categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"},{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://example.com/tags/%E7%94%9F%E6%B4%BB/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"悦读","slug":"悦读","permalink":"http://example.com/tags/%E6%82%A6%E8%AF%BB/"}]}