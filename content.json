{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"bangumi","date":"2020-10-25T04:03:52.000Z","updated":"2020-10-25T05:33:19.982Z","comments":false,"path":"bangumi/index.html","permalink":"http://example.com/bangumi/index.html","excerpt":"","text":""},{"title":"comment","date":"2020-10-25T08:42:31.000Z","updated":"2020-10-25T08:42:31.634Z","comments":true,"path":"comment/index.html","permalink":"http://example.com/comment/index.html","excerpt":"","text":""},{"title":"links","date":"2020-10-25T08:44:14.000Z","updated":"2020-10-25T08:52:54.651Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"donate","date":"2020-10-25T08:44:53.000Z","updated":"2020-10-25T08:54:29.411Z","comments":true,"path":"donate/index.html","permalink":"http://example.com/donate/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-10-25T09:55:08.000Z","updated":"2020-10-25T09:55:08.197Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"life","slug":"life","date":"2020-10-24T13:22:18.000Z","updated":"2020-10-25T09:02:22.413Z","comments":true,"path":"2020/10/24/life/","link":"","permalink":"http://example.com/2020/10/24/life/","excerpt":"","text":"终于搭好了自己的博客 以后更有动力写博客了！！","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://example.com/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"什么是前后端分离","slug":"web","date":"2020-10-24T09:30:14.000Z","updated":"2020-10-25T09:02:33.150Z","comments":true,"path":"2020/10/24/web/","link":"","permalink":"http://example.com/2020/10/24/web/","excerpt":"","text":"概念:前端代码后端代码分开写 非前后端分离会发生的问题 传统web，前端由jsp开发，jsp非后端开发独立完成 前端–&gt;html静态页面–&gt;后端–&gt;jsp（后端可能看不懂前端） 前端只需要独立编写客户端代码，后端只需要独立编写服务器代码提供数据接口即可。 前端通过Ajax请求来访问后端的数据接口，将Model展现到View中即可 前端开发者只需要提前约定好接口文档（url，参数，数据类型）分别独立开发，前端可以用假的数据进行测试，不依赖于后端，解耦，极大提高开发效率。 前后端分离解决了一个问题 那就是静态资源(页面)和动态资源(数据接口)的分离，以前的jsp因为是直接把数据嵌入页面的导致页面资源也是动态的，接下来需要引入cdn缓存的概念，涉及的是运维方面的知识，静态资源一旦进入缓存，是可以有效降低服务器的负载的，这才是重点，也就是性能的提升。 所以前后端分离将一个单体应用拆分为两个独立的应用，前后端以json格式进行数据交互！！！！","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"http://example.com/tags/%E6%82%A6%E8%AF%BB/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}],"author":"tianjin"},{"title":"Spring Boot","slug":"spring boot","date":"2020-10-24T09:30:14.000Z","updated":"2020-10-25T09:21:18.324Z","comments":true,"path":"2020/10/24/spring boot/","link":"","permalink":"http://example.com/2020/10/24/spring%20boot/","excerpt":"","text":"spring boot的基本配置介绍 pom.xml spring-boot-dependencies:核心依赖在父工程中！ 引入spring-boot，不需要指定版本，存在版本仓库 spring-boot的启动器 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 主程序123456@SpringBootApplicationpublic class SpringbootApplication extends WebMvcConfigurerAdapter &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootApplication.class, args); &#125;&#125; @SpringBootApplication:标注这个类是一个springboot应用，启动类下所有资源被导入 我们点开@SpringBootApplication 12345678910111213141516@Sp@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration：spring-boot的配置 //点开SpringBootConfiguration @Target(&#123;ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) @Documented @Configuration public @interface SpringBootConfiguration &#123; @AliasFor( annotation = Configuration.class ) boolean proxyBeanMethods() default true; &#125; 123456789101112131415161718192021222324 - @Configuration：pring配置类 - @Compnent：也是spring boot 的一个组件 - &gt; @EnableAutoConfiguration：自动配置 - &#96;&#96;&#96;JAVA @Target(&#123;ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(&#123;AutoConfigurationImportSelector.class&#125;) public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY &#x3D; &quot;spring.boot.enableautoconfiguration&quot;; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;; &#125; @AutoConfigurationPackage：自动配置包 @Import({AutoConfigurationImportSelector.class})：自动配置导入选择器 超多的自动配置为什么没有生效，需要导入对应的start才能生效，因为注解@ConditionalOnXXX（核心注解）：如果这里面的条件满足，配置才会生效。不导入@ConditionalOnXXX（核心注解）下回报红。 结论：所有的springboot配置都是在启动的时候扫描并加载：spring.factory ，所有的自动配置类都在spring.factory都在里面， 但是不一定生效，因为注解@ConditionalOnXXX，要判断它的条件是否成立，只需要导入对应的start，就有对应的启动器，我们自动装配生效，配置成功！！！！ springboot启动时，从类路径/MATA-INF/spring.factory获取指定值 然后将这些自动配置类导入容器，自动配置就会生效，进行自定配置 之前自配的东西，springboot帮我们做了 整合java ee，解决方案和自动配合的东西都在spring-boot-autoconfigure-2.2.0 Relesaes .jar包 需要的组件，以类名的方式返回，这些组件就会添加到容器中 容器存在许多xxxautoConfiguraion（@Bean）就是这些给容器导入了场景所需要的组件，并进行自动配置@Configguration ，javaConfig","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}],"author":"TianJin"}],"categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"},{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://example.com/tags/%E7%94%9F%E6%B4%BB/"},{"name":"悦读","slug":"悦读","permalink":"http://example.com/tags/%E6%82%A6%E8%AF%BB/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}]}